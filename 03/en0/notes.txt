naive approach:

Trace the first wire and record the (x,y) tuple of each wire accounting for runs of length.

for example: R3 would produce tuples (0,1), (0,2), (0, 3).

Place each tuple into a set().

Next trace the second wire in a similar fashion except rather then recording the tuple,
we would preform a membership check against the recorded set. If we find a member that exists in both sets,
compute the distance as d = abs(x) + abs(y) and keep a running minimum of d and it's corresponding tuple

Alternativly, we could create 2 independent sets, one for the first wire and another for the second then preform
a set intersection check and run the distance sort on the subset elements. 

The second option would be more strait forward and result in less code as it shares component parts. From a
readabillity prospective, the second option seems more appealing.


Other key info:
membership test of python's Set is O(1) in average case
membership add is O(1) in every case
set intersection is O(n) where n is the length of the smaller set.

this makes the time complexity for the first option to be O(2n) to find the intersections and O(j) to find the
nearest intersection where n is the total number of tuples in the larger set and j is the total number of intersections

If we consider n as the total number of tuples in both sets then time complexity is simply O(n)

This is not to bad - not to terribly naive and would be worth coding up to see how it performs

The second option would be O(3n) - thats O(n) to build the left set, O(n) to build the right set, and 
O(n) to do the intersection.  If we consider n to be all nodes, the runtime is O(1.5n) which is just O(2n)

Still linear albeit more complex then the other option.
